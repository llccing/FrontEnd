import{_ as i,c as o,a as n,b as e,d as l,o as t}from"./app-DxUSmTbc.js";const c={};function r(s,a){return t(),o("div",null,[...a[0]||(a[0]=[n('<h1 id="inline-block" tabindex="-1"><a class="header-anchor" href="#inline-block"><span>inline-block</span></a></h1><blockquote><p>“-”表示前缀，意思是block具备inline的性质，让块级元素在一行内显示的性质。</p></blockquote><h2 id="需要留意的点" tabindex="-1"><a class="header-anchor" href="#需要留意的点"><span>需要留意的点</span></a></h2><ol><li>能够设置宽高</li><li>inline-block各个元素，高度不同时，以文本基线对齐，通过vertical-align:top;实现顶部对齐</li></ol><h2 id="float与display-inline-block-对比" tabindex="-1"><a class="header-anchor" href="#float与display-inline-block-对比"><span>float与display: inline-block 对比</span></a></h2>',5),e("iframe",{height:"265",style:{width:"100%"},scrolling:"no",title:"float vs inline-block",src:"https://codepen.io/llccing/embed/dyypmZJ?height=265&theme-id=0&default-tab=html,result",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},[l(" See the Pen "),e("a",{href:"https://codepen.io/llccing/pen/dyypmZJ"},"float vs inline-block"),l(" by llccing ("),e("a",{href:"https://codepen.io/llccing"},"@llccing"),l(") on "),e("a",{href:"https://codepen.io"},"CodePen"),l(". ")],-1),n('<h3 id="共性" tabindex="-1"><a class="header-anchor" href="#共性"><span>共性：</span></a></h3><p>实现元素再一行展示，同时可以自由设置元素大小。</p><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别：</span></a></h3><ul><li>使用float时，要有一个元素包裹float元素，来避免接下来的元素仅仅靠近他。 inline-block 就没有这个问题。</li><li>inline-block会有空白符，设置margin-left: -4px;可以解除。</li><li>inline-block水平排列一行，即使高度不同也会高度最大的元素高度为行高，即使高度小的元素周围留空，也不会有第二个元素补位。可以设置默认的垂直对齐基线。inline-block元素仍然再文档流中占据位置。</li><li>float元素脱离当前文档流，呈环绕状排列，如遇上行有空白并且当前元素能够挤进去，这个元素会补位。默认顶部对齐。</li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><ul><li><p>inline-block，当我们需要设置某些元素再一行展示，并且排列方向一致的情况下，尽可能使用inline-block。因为inline-block的元素仍然再文档流中占据位置，减少了程序对DOM的更改操作，因为DOM每次更改，浏览器就会重绘DOM树，增加性能消耗，同时也不用因为float而清除浮动。</p></li><li><p>float，inline-block作为首选，但是仍有float使用的场景，比如两个元素，一个左排列，一个右排列。这时只能用float实现。浏览器的解析顺序是逐行解析，当设置两个元素右浮动时，代码顺序在前的元素会被先解析。</p></li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/31856017" target="_blank" rel="noopener noreferrer">display:inline-block一些注意点</a></li><li><a href="https://github.com/mynane/web-problem/issues/3" target="_blank" rel="noopener noreferrer">float 与 display: inline-block 区别</a></li><li><a href="https://www.jianshu.com/p/05c48bf43b1a" target="_blank" rel="noopener noreferrer">inline-block 与 float的共性与区别</a></li></ul>',8)])])}const p=i(c,[["render",r]]),d=JSON.parse('{"path":"/css/inline-block.html","title":"inline-block","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768212945000,"contributors":[{"name":"Rowan Liu","username":"","email":"lcf33123@gmail.com","commits":1}],"changelog":[{"hash":"510851a2e40013ba249eb2696f9e38f188ca533a","time":1768212945000,"email":"lcf33123@gmail.com","author":"Rowan Liu","message":"Update README.md"}]},"filePathRelative":"css/inline-block.md"}');export{p as comp,d as data};
